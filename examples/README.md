The examples are the +1 in the 4+1 views of Software engineering.

They define is avery practical and testable way, what are the functional requirements of the system

They are fun and easy to write, as they are like telling a story

We go from very simple systems

- A Cart pole gym, just sycrnous python

To very complicated

- An entire mrf in the box, 1000s of computers and robots, async, a full data engine with different type of transport layers, different computers, etc. etc...


How to make sure we are meeting the object and not regressing?

- One interesting idea is that all of these systems start as babies and then progress...
- The cool thing is that we could
- A hard thing is that all of them we cannot "test" its working unit it learns. Once it learn though then we can prevent regressions..
- Some learning can be done in code fast with if else statements, some is harder though needs to be trial and error...

ai_compile.

Compile py nodes to anythign else...

Actually even the first pyp node we can write with ai compile. then its more of a rpomopt copmile though...

We can at any time recompile the entire repository of code... this is a very different way to program. feels more like optimization, and setting of constraints and objects with examples and unit tests, etc.

backprop does search in nneural networkspace
llms do search in program space (via high proabilistic heuristic + trial and error)

In both cases we need an objective function, which it should continue to improve

And llms are cool in that they are doing "non deriviate, gradient free optimization" so can easily handle constraints (unit tests)

A component based architecture not only helps you design it, but it also turns it into simple easy verifiable pieces that the ai can solve one at a time, or approach in tandem, rewriting entire sections to combine them in a more optimized manner (ie. run time, etc.) all for say some higher level fucntion of pick time or reward, etc.

Amazingly powerful now with background agents, you can just set them off and they can work on these components in parrallel.... its insane really!

what I am really writing then are essentially markdown files, which describe the code to write. etc. real tests, real rewards...


So how will I start, start with the story and the examples...
then write out the component architecture that will allow you to achieve that
then write out the prompts to implement that archieture.
Then sit back and relax and let the search otpimize essentially... thats insane! TDD...

Give up being careful about the actual implementations. just like with neural networks how we give up caring about how the orgnzation happens inside. 

This is a completely new approach to handle complexity which is awesome...

I like how the robo flow calls them v1, v2, v3 etc.. its almost non human readable, and with a goal! perhaps we should make the code non human readable lol... program in a different langauage to really make sure we are not messing around with it...

I like the idea of having the folder structure with ai_compile/prompts tests, and then the src code which we really never look at suprisingly!


Each folder is a self contained application, similar to how you can use lk for your own application.

For some of the advanced features you we can use simulation if you want to verify them, which is really cool. We can even verify IRL though.. wow ok this seems a competly new way to program.